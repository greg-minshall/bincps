## WARNING:
##
## this file is generated from the emacs .org file "kblom.org" via
## "tangling".  any modifications to this file will be lost the next
## time the .org file is tangled.  this file is provided for the use
## of users who don't use emacs, or don't use org-mode.
## 

require(Hmisc, warn.conflicts=FALSE, quietly=TRUE)

check.binned <- function(fname, vals, nobs) {
  if (length(vals) == 0) {
    stop(sprintf("%s: no values", fname))
  } else if (length(nobs) == 0) {
    stop(sprintf("%s: no observations", fname))
  } else if (length(vals) != length(nobs)) {
    stop(sprintf("%s: length(values) [%d] != length(number of observations) [%d]",
                 fname, length(vals), length(nobs)))
  } else if (!is.numeric(vals[!is.na(vals)])) {
    stop(sprintf("%s: values must be numeric", fname))
  } else if (!is.numeric(nobs[!is.na(nobs)])) {
    stop(sprintf("%s: number of observations must be numeric", fname))
  }
}

## so, in ecdf():

## - vals are the unique values of x

## - match(x, vals) are, for each value of x, the index of that value
##   of x in vals.  length(match(x, vals)) == length(x).

## - tabulate(match(x, vals)) returns, for each *index* in vals (i.e.,
##   in 1:length(vals)), the number of *times* that index appears in
##   match(x, vals), i.e., how often each value in x appears in x.
##   sort of a pdf of x.  length(tabulate(match(x, vals))) ==
##   max(match(x, vals)) == [because of sorting, indexing] length(vals)

##   (note that all these are ordered by index in vals, which, because
##   of sort, are ordered by value of x)

## - cumsum(tabulate(match(x, vals)) produces a CDF, from 1:n of, for
##   each unique value in x, how often that value occurs in x.

## - so, finally, cumsum(tabulate(match(x, vals)))/n produces a CDF
##   with the standard values, i.e., in [0,1).

## - then approxfun(vals, cumsum(tabulate(match(x, vals)))/n, ...)
##   produces a function that, when called for a given value in vals
##   (the unique values in x), returns the corresponding value of the
##   CDF in [0,1).

ecdf.binned.common <- function(x, nobs, inverse, from) {
  "like ecdf, but for binned values; cribbed from ecdf.  this works for forward function (ecdf.binned) and for inverse function (iecdf.binned)"
  check.binned(from, x, nobs)
  wet <- wtd.Ecdf(x=x, weights=nobs)     # get table
  if (!inverse) {
    X <- wet$x
    yleft <- 0
    yright <- 1
    Y <- wet$ecdf
  } else {
    X <- wet$ecdf
    Y <- wet$x
    yleft <- X[1]
    yright <- X[length(X)]
  }
  rval <- approxfun(X, Y,
                    method="constant",
                    yleft = yleft, yright = yright,
                    f = 0,              # XXX is this the right f for inverse?
                    ties = "ordered")
  # class(rval) <- c("ecdf", "stepfun", class(rval))
  assign("nobs", sum(nobs), envir = environment(rval))
  attr(rval, "call") <- sys.call()
  rval
}

ecdf.binned <- function(x, nobs) {
  "like ecdf, but for binned values; cribbed from ecdf"
  ecdf.binned.common(x, nobs, inverse = FALSE, "ecdf.binned")
}

iecdf.binned <- function(x, nobs) {
  "this is the inverse function from ecdf.binned
 (allowing you to get order statistics easily);
probably \"slight\" overkill for that usage"
  ecdf.binned.common(x, nobs, inverse = TRUE, "iecdf.binned")
}

summary.binned <- function(vals, nobs) {
  if ((length(vals[!is.na(vals)]) == 0) ||
      (length(nobs[!is.na(nobs)]) == 0)) { # "||"? i'm not sure
    return(c(Min=NA, "1st Qu."=NA, Median=NA, Mean=NA, "3rd Qu."=NA, "Max."=NA))
  }
  check.binned("summary.binned", vals, nobs)

  result <- wtd.quantile(x=vals, weights=nobs,
                         probs=c(0, .25, .5, 0, .75, 1))
  names(result) <- c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.")
  result["Mean"] <- wtd.mean(x=vals, weights=nobs)
  return(result)
}

rebin.binned <- function(vals, nobs, newvals, ordered=FALSE) {
  "given a set of values, with its set of observations counts,
produce a new set of bins, with a new set of observation counts.
the old values vals must fit \"integrally\" into the new vals.
returns the new observation counts."
  ## only care about actual observed outcomes (and, this makes it
  ## easier to have newvals technically smaller than max(vals), in
  ## case where max(vals) is not actually an observed value.
  vals <- vals[nobs!=0]
  nobs <- nobs[nobs!=0]
  if (!ordered) {
    path <- order(vals)
    newvals <- newvals[order(newvals)]
  } else {
    path <- 1:length(vals)
  }
  if (length(vals) != length(nobs)) {
    stop(sprintf("rebin.binned: length(vals) [%d] != length(nobs) [%d]",
                  length(vals), length(nobs)))
  }
  if (vals[length(vals)] > newvals[length(newvals)]) {
    stop(sprintf("rebin.binned: largest current observed bin (%d) greater than largest new bin (%d)",
                 vals[length(vals)], newvals[length(newvals)]))
  }
  j <- 1                              # index into newvals
  rval <- integer()                   # initialize return value
  count <- 0                          # intialize count (rval element)
  for (i in path) {
    if (vals[i] > newvals[j]) {         # we're in a new bucket
      rval <- c(rval, count)            # so, finish out the previous bucket
      toskip <- sum(vals[i] > newvals[j:length(newvals)])
      count <- 0                        # reinitialize count
      rval <- c(rval, rep(0, toskip-1)) # we may have quite a way to go
      j <- j+toskip                     # fast forward
    }
    count <- count + nobs[i]
  }
  rval <- c(rval, count)                # get last count
  ## fill out rval
  rval <- c(rval, rep(0, length(newvals)-length(rval)))
  rval                                  # return value
}

rebinvals.binned <- function(limita, limitb=NA, binsize) {
  "return the set of new values for a given new BINSIZE.  
  can specify MIN and MAX, or just pass the set of observations
  and the new min, max, will be computed."
  min <- min(c(limita, limitb), na.rm=TRUE)
  max <- max(c(limita, limitb), na.rm=TRUE)
  lo <- (floor(min/binsize)+1)*binsize
  hi <- (floor(max/binsize)+1)*binsize
  return(seq(lo, hi, binsize))
}

test.rebin.binned <- function() {
  "some unit tests"
  ## basic functionality works?
  if (!identical(rebin.binned(c(1:20), seq(1,20), seq(2,20,by=2)),
                 seq(3, 39, 4))) {
    stop("test.rebin.binned: verification failed")
  }

  ## what if old bin had something too big, but unobserved?
  if (!identical(rebin.binned(c(1:21), c(seq(1,20),0), seq(2,20,by=2)),
                 seq(3, 39, 4))) {
    stop("test.rebin.binned: verification failed")
  }
}


test.rebinvals.binned <- function() {
  "trivial unit test for rebinvals.binned; built around
  for (i in c(-6:6, 24:29)) print(rebinvals.binned(i:29, binsize=5))"
  testpat <- list(
                  list(-6, c(-5, 0, 5, 10, 15, 20, 25, 30)),
                  list(-5, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-4, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-3, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-2, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-1, c(0, 5, 10, 15, 20, 25, 30)),
                  list(0, c(5, 10, 15, 20, 25, 30)),
                  list(1, c(5, 10, 15, 20, 25, 30)),
                  list(2, c(5, 10, 15, 20, 25, 30)),
                  list(3, c(5, 10, 15, 20, 25, 30)),
                  list(4, c(5, 10, 15, 20, 25, 30)),
                  list(5, c(10, 15, 20, 25, 30)),
                  list(6, c(10, 15, 20, 25, 30)),
                  list(24, c(25, 30)),
                  list(25, c(30)),
                  list(26, c(30)),
                  list(27, c(30)),
                  list(28, c(30)),
                  list(29, c(30)))
  for (x in testpat) {
    i <- x[[1]]
    z <- x[[2]]
    zz <- rebinvals.binned(i:29, binsize=5)
    if (!identical(z, zz)) {
      print(z); print(zz);
    }
  }
}
