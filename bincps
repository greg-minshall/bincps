#!/usr/bin/env Rscript
## WARNING:
##
## this file is generated from the emacs .org file "kblom.org" via
## "tangling".  any modifications to this file will be lost the next
## time the .org file is tangled.  this file is provided for the use
## of users who don't use emacs, or don't use org-mode.
## 
## WARNING:
##
## this file is generated from the emacs .org file "kblom.org" via
## "tangling".  any modifications to this file will be lost the next
## time the .org file is tangled.  this file is provided for the use
## of users who don't use emacs, or don't use org-mode.
## 

require(Hmisc, warn.conflicts=FALSE, quietly=TRUE)

check.binned <- function(fname, vals, nobs) {
  if (length(vals) == 0) {
    stop(sprintf("%s: no values", fname))
  } else if (length(nobs) == 0) {
    stop(sprintf("%s: no observations", fname))
  } else if (length(vals) != length(nobs)) {
    stop(sprintf("%s: length(values) [%d] != length(number of observations) [%d]",
                 fname, length(vals), length(nobs)))
  } else if (!is.numeric(vals[!is.na(vals)])) {
    stop(sprintf("%s: values must be numeric", fname))
  } else if (!is.numeric(nobs[!is.na(nobs)])) {
    stop(sprintf("%s: number of observations must be numeric", fname))
  }
}

summary.binned <- function(vals, nobs) {
  if ((length(vals[!is.na(vals)]) == 0) ||
      (length(nobs[!is.na(nobs)]) == 0)) { # "||"? i'm not sure
    return(c(Min=NA, "1st Qu."=NA, Median=NA, Mean=NA, "3rd Qu."=NA, "Max."=NA))
  }
  check.binned("summary.binned", vals, nobs)

  result <- wtd.quantile(x=vals, weights=nobs,
                         probs=c(0, .25, .5, 0, .75, 1))
  names(result) <- c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.")
  result["Mean"] <- wtd.mean(x=vals, weights=nobs)
  return(result)
}

rebin.binned <- function(vals, nobs, newvals, ordered=FALSE) {
  "given a set of values, with its set of observations counts,
produce a new set of bins, with a new set of observation counts.
the old values vals must fit \"integrally\" into the new vals.
returns the new observation counts."
  ## only care about actual observed outcomes (and, this makes it
  ## easier to have newvals technically smaller than max(vals), in
  ## case where max(vals) is not actually an observed value).
  vals <- vals[nobs!=0]
  nobs <- nobs[nobs!=0]
  if (!ordered) {
    path <- order(vals)
    newvals <- newvals[order(newvals)]
  } else {
    path <- 1:length(vals)
  }
  if (length(vals) != length(nobs)) {
    stop(sprintf("rebin.binned: length(vals) [%d] != length(nobs) [%d]",
                  length(vals), length(nobs)))
  }
  if (vals[length(vals)] > newvals[length(newvals)]) {
    stop(sprintf("rebin.binned: largest current observed bin (%d) greater than largest new bin (%d)",
                 vals[length(vals)], newvals[length(newvals)]))
  }
  j <- 1                              # index into newvals
  rval <- integer()                   # initialize return value
  count <- 0                          # intialize count (rval element)
  for (i in path) {
    if (vals[i] > newvals[j]) {         # we're in a new bucket
      rval <- c(rval, count)            # so, finish out the previous bucket
      toskip <- sum(vals[i] > newvals[j:length(newvals)])
      count <- 0                        # reinitialize count
      rval <- c(rval, rep(0, toskip-1)) # we may have quite a way to go
      j <- j+toskip                     # fast forward
    }
    count <- count + nobs[i]
  }
  rval <- c(rval, count)                # get last count
  ## fill out rval
  rval <- c(rval, rep(0, length(newvals)-length(rval)))
  rval                                  # return value
}


rebinvals.binned <- function(limita, limitb=NA, binsize) {
  "return the set of new values for a given new BINSIZE.  
  can specify MIN and MAX, or just pass the set of observations
  and the new min, max, will be computed."
  min <- min(c(limita, limitb), na.rm=TRUE)
  max <- max(c(limita, limitb), na.rm=TRUE)
  lo <- (floor(min/binsize)+1)*binsize
  hi <- (floor(max/binsize)+1)*binsize
  return(seq(lo, hi, binsize))
}

test.rebin.binned <- function() {
  "some unit tests"
  ## basic functionality works?
  if (!identical(rebin.binned(c(1:20), seq(1,20), seq(2,20,by=2)),
                 seq(3, 39, 4))) {
    stop("test.rebin.binned: verification failed")
  }

  ## what if old bin had something too big, but unobserved?
  if (!identical(rebin.binned(c(1:21), c(seq(1,20),0), seq(2,20,by=2)),
                 seq(3, 39, 4))) {
    stop("test.rebin.binned: verification failed")
  }
}


test.rebinvals.binned <- function() {
  "trivial unit test for rebinvals.binned; built around
  for (i in c(-6:6, 24:29)) print(rebinvals.binned(i:29, binsize=5))"
  testpat <- list(
                  list(-6, c(-5, 0, 5, 10, 15, 20, 25, 30)),
                  list(-5, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-4, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-3, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-2, c(0, 5, 10, 15, 20, 25, 30)),
                  list(-1, c(0, 5, 10, 15, 20, 25, 30)),
                  list(0, c(5, 10, 15, 20, 25, 30)),
                  list(1, c(5, 10, 15, 20, 25, 30)),
                  list(2, c(5, 10, 15, 20, 25, 30)),
                  list(3, c(5, 10, 15, 20, 25, 30)),
                  list(4, c(5, 10, 15, 20, 25, 30)),
                  list(5, c(10, 15, 20, 25, 30)),
                  list(6, c(10, 15, 20, 25, 30)),
                  list(24, c(25, 30)),
                  list(25, c(30)),
                  list(26, c(30)),
                  list(27, c(30)),
                  list(28, c(30)),
                  list(29, c(30)))
  for (x in testpat) {
    i <- x[[1]]
    z <- x[[2]]
    zz <- rebinvals.binned(i:29, binsize=5)
    if (!identical(z, zz)) {
      print(z); print(zz);
    }
  }
}

getout <- function(message, code) {
  if (interactive()) {
    stop(message)
  } else {
    cat(message)
    quit(save="no", status=code)
  }
}


bincps <- function(ifile,      # input file
                   ofile="",   # output csv file ("" ==>
                                        # compute from ifile)
                   ofsep="-",  # separator (when ofile or rfile blank)
                   rfile="",   # output report file (see ofile)
                   fyear=-Inf, # first year to include
                   lyear=Inf,  # last year to include
                   min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                   max99=Inf,  # maximum HH{INCOME,BRACKET}99 (in USD)
                   ## things < min99, > max99 are included in the
                   ## smallest and largest bins; NA are not included
                   binsize=1000,    # size of bins
                   trimends=TRUE,   # don't output out of range income
                   infminmax=FALSE, # label too small -Inf, too large Inf?
                   verbose=1        # how verbose to be
                   ) {
  if (verbose > 0) {
    cat(sprintf("about to read.csv %s\n", date()))
  }
  dset <<- read.csv(ifile, header=TRUE)
  if (verbose > 0) {
    cat(sprintf("done with read.csv %s\n", date()))
  }
  if (nrow(dset) == 0) {
    getout(sprintf("no data in dataset \"%s\"\n", ifile), 1)
  }

  ## get rid of records outside our years of interest (fyear, lyear)
  if ((fyear != -Inf) || (lyear != Inf)) {
    dset <- dset[dset$YEAR >= fyear & dset$YEAR <= lyear,]
  }

  if (nrow(dset) == 0) {
    getout(sprintf("no data in dataset \"%s\" for years between %g and %g\n",
                   ifile, fyear, lyear), 1)
  }

  ## now, make min99, max99 multiples of binsize
  if (!is.infinite(min99)) {
    min99 <- (min99%/%binsize)*binsize
  }
  if (!is.infinite(max99)) {
    max99 <- (((max99-1)%/%binsize)*binsize)+binsize
  }

  ## now, check if output files are okay
  orlabel <- sprintf("%d%s%d", min(dset$YEAR), ofsep, max(dset$YEAR))
  ofto <- ofsep
  if (min99 != -Inf) {
    orlabel <- sprintf("%s%s%d", orlabel, ofsep, min99);
    ofto <- sprintf("%sto%s", ofsep, ofsep)
  }
  if (max99 != Inf) {
    orlabel <- sprintf("%s%sto%s%d", orlabel, ofsep, ofsep, max99);
    ofto <- ofsep
  }
  orlabel <- sprintf("%s%sbinned", orlabel, ofto)
  rrlabel <- sprintf("%s%sreport", orlabel, ofsep)
  ofile <- dealwithoutputfilename(ifile, ofile, "output", orlabel)
  rfile <- dealwithoutputfilename(ifile, rfile, "report", rrlabel)

  ## we may be running on "raw" (via ipums) census data, or we may be
  ## looking at output of a previous run (already binned).  which is it?
  if (is.element("HHINCOME", colnames(dset))) {
    income99 <- "HHINCOME99"
    ## now, convert all income to 1999 dollars
    dset <- cbind(dset,
                  HHINCOME99=dset$HHINCOME*dset$CPI99, # normalize to 1999 dollars
                  NRESP=1)              # number of responses
  } else if (is.element("HHBRACKET99", colnames(dset))) {
    income99 <- "HHBRACKET99"
    ## what is input binsize?  to figure this out, we look at the
    ## smallest difference between successive HHBRACKET99's
    x <- dset$HHBRACKET99                   # brackets
    y <- unique(c(x[2:length(x)], NA) - x) # list of unique deltas + NA
    ibsize <- min(abs(y), na.rm=TRUE)   # take min, ignoring NA
    if (is.na(ibsize)) {
      getout(sprintf("unable to compute input binsize of input file \"%s\"\n",
                     ifile), 1)
    }
    ## now, is the input binsize a divisor of the desired output binsize?
    if ((ibsize%%binsize) != 0) {
      getout(sprintf("the input file appears to have a binsize of %d, but the desired binsize %d is not a multiple of this\n",
                     ibsize, binsize), 1)
    }
  } else {
    getout("bincps: input has neither HHINCOME (raw) or HHBRACKET99 (output of previous run\n", 1)
  }

  rval <- bincps1(dset=dset,
                  min99=min99,
                  max99=max99,
                  binsize=binsize,
                  trimends=trimends,
                  infminmax=infminmax,
                  verbose=verbose,
                  income99=income99)

  bset <- rval$bset
  rset <- rbind(rval$rsetun, rval$rsethwt, rval$rsetwt)
  write.csv(rval$bset, ofile, row.names=FALSE, quote=FALSE);
  if (nrow(rset) != 0) {                # anything to report?
    ## if so, first sort it, then write it out
    rset <- rset[order(rset$YEAR, rset$"Max."),]
    write.csv(rset, rfile, row.names=FALSE, quote=FALSE)
  }
}

bincps1 <- function(dset,                # inherits other locals from
                    min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                    max99=Inf, # maximum HH{INCOME,BRACKET}99 (in USD)
                    ## things < min99, > max99 are included in the
                    ## smallest and largest bins; NA are not included
                    binsize=1000,        # size of bins
                    trimends=TRUE,
                    infminmax=FALSE,     # should min/max bins be
                                         # labelled "[-]Inf"?  if this
                                         # is FALSE, < min99 will go
                                         # just below the lowest bin,
                                         # and >= max99 will go just
                                         # above the highest bin
                    verbose=1,
                    income99
                    ) {
  ## get *all* the bins...
  dset <- cbind(dset, BRACKET=(floor(dset[,income99]/binsize)*binsize)+binsize)

  ## this is in lieu of a macro facility in R (or in lieu of 
  ## working in org-mode when running code via C-c C-c).  this routine
  ## is called to enter rows into the output table (and, can access --
  ## read and write -- our variables from the calling routine)
  ahroutine <- function(filter, bracket) {
    if (verbose > 1) {
      cat(sprintf("ahroutine, year %d, nrow filter %d, bracket %g, nrow bset %d\n",
                    year, nrow(yset[filter,]), bracket, nrow(bset)))
    }
    for (asecflag in unique(yset[filter,]$ASECFLAG)) {
      if (!is.na(asecflag)) {
        sa <- filter & yset$ASECFLAG == asecflag
      } else {
            sa <- filter & is.na(yset$ASECFLAG)
      }
      for (hflag in unique(yset[sa,]$HFLAG)) {
        if (!is.na(hflag)) {
          sh <- sa & yset$HFLAG == hflag
        } else {
          sh <- sa & is.na(yset$HFLAG)
        }
        if (nrow(yset[sh,]) != 0) {
          ## *finally* -- do something!
          month <- unique(yset[sh,]$MONTH)
          if (length(month) > 1) {
            month <- NA
          }
          cpi99 <- unique(yset[sh,]$CPI99)
          if (length(cpi99) > 1) {
            cpi99 <- NA
          }
          bset <<- rbind(bset,
                         data.frame(YEAR=year,
                                    HWTSUPP=sum(yset[sh,]$HWTSUPP),
                                    ASECFLAG=asecflag,
                                    HFLAG=hflag,
                                    HHBRACKET99=bracket,
                                    CPI99=cpi99,
                                    MONTH=month,
                                    WTSUPP=sum(yset[sh,]$WTSUPP),
                                    NRESP=sum(yset[sh,]$NRESP)))
        }
      }
    }
  }

  mysummary <- function(vals, nobs=NULL) {
    "like summary, but try for a format consistent across numbers, NA, ..."
    if (is.null(nobs)) {
      nobs <- rep(1, length(vals))
    }
    summary <- summary.binned(vals, nobs);
    if("NA's" %in% names(summary)) {
      summary <- summary[-which(names(summary) == "NA's")]
    }
    ## make names consistent (else rbind() complains)
    names(summary) <- c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.")
    return(summary)
  }

  ## deal with execptional data, i.e., data that is either
  ## NA-contaminated, or data that is outside the min99/max99 bounds
  rsetting <- function(filter, comment) {
    commentun <- sprintf("(unweighted) %s", comment)
    commenthwt <- sprintf("(hwtsupp-weighted) %s", comment)
    commentwt <- sprintf("(wtsupp-weighted) %s", comment)
    rsetun <<- rbind(rsetun,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99]),
                                    COMMENT=commentun))))
    rsethwt <<- rbind(rsethwt,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99],
                                              yset[filter,]$HWTSUPP),
                                    COMMENT=commenthwt))))
    rsetwt <<- rbind(rsetwt,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99],
                                              yset[filter,]$WTSUPP),
                                    COMMENT=commentwt))))
  }

  ## the binned data goes here
  bset <- data.frame()
  ## three data frames for exception reporting.  the first is
  ## unweighted "income99" (HHINCOME99 or HHBRACKET99, as the case may
  ## be); the second weighted by HWTSUPP; and the third by WTSUPP.
  rsetun <- data.frame()
  rsethwt <- data.frame()
  rsetwt <- data.frame()
  for (year in sort(unique(dset$YEAR))) {
    yset <- dset[dset$YEAR == year,]
    sy <- TRUE                          # initially, take all in this year
    if (verbose > 0) {
      cat(sprintf("%s %s\n", year, date()))
    }

    ## get rid of out of universe, etc., codes
    ## https://cps.ipums.org/cps/inctaxcodes.shtml
    if ("HHINCOME" %in% colnames(yset)) {
      stopbit <- yset[,"HHINCOME"] %in% c(-9999997, -9999, 9999, 99990, 99991, 99992, 99994, 99995, 99996, 99997, 99998, 99999, 99999999)
      stop <- sy & stopbit
      if (nrow(yset[stop,]) != 0) {
        rsetting(stop, "topcodes (Census Bureau/IPUMS coded as invalid)")
        sy <- sy & !stopbit             # get rid of these
      }
    }

    snabit <- is.na(yset[,income99])
    sna <- sy & snabit
    if (nrow(yset[sna,]) != 0) {
      ahroutine(sna, NA)                # enter (these) row(s)
      rsetting(sna, "income not provided")
      sy <- sy & !snabit                # now, kill them
    }

    ## describe and enter the too small incomes
    slowbit <- yset[,income99] < min99
    slow <- sy & slowbit
    if (nrow(yset[slow,]) != 0) {
      if (!trimends) {                  # should we describe these?
        ## enter (these) row(s)
        if (!infminmax) {
          ahroutine(slow, min99)
        } else {
          ahroutine(slow, -Inf)
        }
      }
      rsetting(slow, sprintf("less than %d", min99))
      sy <- sy & !slowbit               # now, kill them
    }

    ## now, describe too high incomes (and then enter them below)
    shighbit <- yset[,income99] >= max99
    shigh <- sy & shighbit
    if (nrow(yset[shigh,]) != 0) {
      rsetting(shigh, sprintf("greater than or equal to %d", max99))
      sy <- sy & !shighbit              # now, kill them
    }

    ## we don't describe *other* bins since they are of limited bracket;
    ## the "negative" and "greater than max" bins are not of an a
    ## priori known limit.

    ## now, add all the bins (if there are any!)
    uy <- unique(yset[sy,]$BRACKET)
    if (!is.null(uy)) {
      for (bin in sort(uy)) {
        sb <- sy & yset$BRACKET == bin
        ahroutine(sb, bin)
      }
    }

    ## now, add too high
    if (nrow(yset[shigh,]) != 0) {
      if (!trimends) {
        ## enter (these) row(s)
        if (!infminmax) {
          ahroutine(shigh, max99+binsize)
        } else {
          ahroutine(shigh, Inf)
        }
      }
    }
  }
  return(list(bset=bset, rsetun=rsetun, rsethwt=rsethwt, rsetwt=rsetwt))
}

## if necessary, cons up an appropriate FNAME.  then, checks that
## FNAME doesn't already exist and that it is (potentially) writeable.

## NB: as a side effect of testing writeability, on a successful
## return, FNAME *will* exist (but, be empty).
dealwithoutputfilename <- function(ifile, fname, use, lastbits) {
  require(assertthat, quietly=TRUE)     # XXX still needed?

  if (is.na(fname)) {                    # compute filename
    x <- strsplit(ifile, ".", fixed=TRUE)[[1]]
    if (x[length(x)] == "gz") {
      length(x) = length(x)-1           # get rid of .gz (we don't compress)
    }
    x[length(x)] <- sprintf("%s.%s", lastbits, x[length(x)]);
    fname <- paste(x, collapse=".")
  }

  ## test if already exists (a no-no)
  if (file.exists(fname)) {
    getout(sprintf("%s file \"%s\" exists, won't overwrite\n", use, fname), 2)
  }

  ## test if writeable (better be!)
  failed <- FALSE;
  x <- tryCatch(file(fname, "w"), 
                error=function(e) failed <<- TRUE);
  if (failed) {
    getout(sprintf("%s file \"%s\" is not writeable\n", use, fname), 2)
  }
  close(x)

  return(fname)
}

main <- function(args=NULL) {
  require(argparser, quietly=TRUE)

  p <- arg_parser("bincps")
  p <- add_argument(p, "--ifile", type="character", default=NA,
                    help="input data (.csv or .csv.gz) file")
  p <- add_argument(p, "--ofile", type="character", default=NA,

                    help="output data file; if not specified, an automatically generated name will be used")
  p <- add_argument(p, "--rfile", type="character", default=NA,
                    help="output exception report file; if not specified, an automatically generated name will be used")
  p <- add_argument(p, "--ofsep", type="character", default="-",
                    help="separator used when automatically generating ofile, rfile names")
  p <- add_argument(p, "--fyear", type="integer", default=-Inf,
                    help="first year to process; if not specified, the first year in the input file will be used")
  p <- add_argument(p, "--lyear", type="integer", default=Inf,
                    help="last year to process; if not specified, the last year in the input file will be used")
  p <- add_argument(p, "--binsize", type="integer", default=1000,
                    help="output bin size")
  p <- add_argument(p, "--min99", type="integer", default=-Inf, short="-m",
                    help="don't bin dollar amounts below this value")
  p <- add_argument(p, "--max99", type="integer", default=Inf, short="-M",
                    help="don't bin dollar amounts above this value")
  p <- add_argument(p, "--verbose", type="integer", default=0,
                    help="informational/debugging output quantity")
  p <- add_argument(p, "--trimends", flag=TRUE, default=TRUE,
                    help="should < MIN99 and > MAX99 be left out of output?")
  p <- add_argument(p, "--infminmax", flag=TRUE, default=FALSE,
                    help="should bins for values below min99 (resp. above max99) appear as \"-Inf\" (resp. \"Inf\"); if not, they will be assigned bins just below min99 (resp. just above max99)")

  if (is.null(args)) {
    argv <- parse_args(p)
  } else {
    argv <- parse_args(p, args)
  }

  bincps(ifile=argv$ifile,
         ofile=argv$ofile,
         rfile=argv$rfile,
         ofsep=argv$ofsep,
         fyear=argv$fyear,
         lyear=argv$lyear,
         binsize=argv$binsize,
         min99=argv$min99,
         max99=argv$max99,
         verbose=argv$verbose,
         trimends=argv$trimends,
         infminmax=argv$infminmax);
}

runargs <- function(ifile,      # input file
                    ofile=NA,   # output csv file ("" ==>
                                        # compute from ifile)
                    ofsep="-",  # separator (when ofile or rfile blank)
                    rfile=NA,   # output report file (see ofile)
                    fyear=-Inf, # first year to include
                    lyear=Inf,  # last year to include
                    min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                    max99=Inf, # maximum HH{INCOME,BRACKET}99 (in USD)
                    ## things < min99, > max99 are included in the
                    ## smallest and largest bins; NA are not included
                    binsize=1000,        # size of bins
                    infminmax=FALSE,     # label too small -Inf, too large Inf?
                    verbose=1            # how verbose to be
                    ) {
  cmdline <- c("--ifile", ifile,
               "--verbose", verbose)

  main(cmdline)
}

options(error=recover)
options(warn=2)
# debug(bincps1)



if (!interactive()) {
  main()
  print(warnings())
}
