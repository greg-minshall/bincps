#!/usr/bin/env Rscript
## WARNING:
##
## this file is generated from the emacs .org file "kblom.org" via
## "tangling".  any modifications to this file will be lost the next
## time the .org file is tangled.  this file is provided for the use
## of users who don't use emacs, or don't use org-mode.
## 
## WARNING:
##
## this file is generated from the emacs .org file "kblom.org" via
## "tangling".  any modifications to this file will be lost the next
## time the .org file is tangled.  this file is provided for the use
## of users who don't use emacs, or don't use org-mode.
## 

check.binned <- function(fname, vals, nobs) {
  if (length(vals) == 0) {
    stop(sprintf("%s: no values", fname))
  } else if (length(nobs) == 0) {
    stop(sprintf("%s: no observations", fname))
  } else if (length(vals) != length(nobs)) {
    stop(sprintf("%s: length(values) [%d] != length(number of observations) [%d]",
                 fname, length(vals), length(nobs)))
  } else if (!is.numeric(vals[!is.na(vals)])) {
    stop(sprintf("%s: values must be numeric", fname))
  } else if (!is.numeric(nobs[!is.na(nobs)])) {
    stop(sprintf("%s: number of observations must be numeric", fname))
  }
}

tabulate.binned <- function(bin, counts, nbins = max(1L, bin, na.rm = TRUE)) {
  "tabulate binned integers: 'bin' is observation; 'counts' are counts of corresponding observation; much cribbed from tabulate()"
  if ((!is.numeric(bin)) && !is.factor(bin)) {
    stop("'bin' must be numeric or a factor")
  }
  if (!is.numeric(counts)) {
    stop("'nobs' must be numeric")
  }
  if (typeof(bin) != "integer") {
    bin <- as.integer(bin)
  }
  if (nbins > .Machine$integer.max) {
    stop(sprintf("attempt to make a table with >= %d elements",
                 .Machine$integer.max))
  }
  nbins <- as.integer(nbins)
  if (is.na(nbins)) {
    stop(gettextf("invalid value of %s", "'nbins'"), domain = NA)
  }
  if (length(bin) != length(counts)) {
    stop(sprintf("length 'bin' %d not same as length 'counts' %d",
                 length(bin), length(counts)))
  }
  ## tabulate here calls .Internal(tabulate(bin, nbins)).  we, not
  ## having recourse to this...
  rval <- rep(0, max(bin))              # this is the result
  vals <- unique(bin)
  for (val in vals) {
    rval[val] <- sum(counts[bin==val])  # if counts == 1, same as tabulate()
  }
  rval
}

## so, in ecdf():

## - vals are the unique values of x

## - match(x, vals) are, for each value of x, the index of that value
##   of x in vals.  length(match(x, vals)) == length(x).

## - tabulate(match(x, vals)) returns, for each *index* in vals (i.e.,
##   in 1:length(vals)), the number of *times* that index appears in
##   match(x, vals), i.e., how often each value in x appears in x.
##   sort of a pdf of x.  length(tabulate(match(x, vals))) ==
##   max(match(x, vals)) == [because of sorting, indexing] length(vals)

##   (note that all these are ordered by index in vals, which, because
##   of sort, are ordered by value of x)

## - cumsum(tabulate(match(x, vals)) produces a CDF, from 1:n of, for
##   each unique value in x, how often that value occurs in x.

## - so, finally, cumsum(tabulate(match(x, vals)))/n produces a CDF
##   with the standard values, i.e., in [0,1).

## - then approxfun(vals, cumsum(tabulate(match(x, vals)))/n, ...)
##   produces a function that, when called for a given value in vals
##   (the unique values in x), returns the corresponding value of the
##   CDF in [0,1).

ecdf.binned.common <- function(x, nobs, inverse) {
  "like ecdf, but for binned values; cribbed from ecdf.  this works for forward function (ecdf.binned) and for inverse function (iecdf.binned)"
  check.binned("summary.ecdf", x, nobs)
  order <- order(x)
  x <- x[order]
  nobs <- nobs[order]
  n <- sum(nobs)                        # w/b length(n) if nobs==1
  if (n < 1) {
    stop("'x' must have 1 or more non-missing values")
  }
  vals <- unique(x)
  X <- vals
  yleft <- 0
  yright <- 1
  Y <- cumsum(tabulate.binned(match(x, vals), counts=nobs))/n
  if (inverse) {
    tmp <- X
    X <- Y
    Y <- tmp
    yleft <- x[1]
    yright <- x[length(x)]
  }
  rval <- approxfun(X, Y,
                    method="constant",
                    yleft = yleft, yright = yright,
                    f = 0,              # XXX is this the right f for inverse?
                    ties = "ordered")
  # class(rval) <- c("ecdf", "stepfun", class(rval))
  assign("nobs", n, envir = environment(rval))
  attr(rval, "call") <- sys.call()
  rval
}

ecdf.binned <- function(x, nobs) {
  "like ecdf, but for binned values; cribbed from ecdf"
  ecdf.binned.common(x, nobs, inverse = FALSE)
}

iecdf.binned <- function(x, nobs) {
  "this is the inverse function from ecdf.binned (allowing you to get order statistics easily); probably \"slight\" overkill for that usage"
  ecdf.binned.common(x, nobs, inverse = TRUE)
}

summary.binned <- function(vals, nobs) {
  check.binned("summary.binned", vals, nobs)
  if ((length(vals[!is.na(vals)]) == 0) ||
      (length(nobs[!is.na(nobs)]) == 0)) { # "||"? i'm not sure
    return(c(Min=NA, "1st Qu."=NA, Median=NA, Mean=NA, "3rd Qu."=NA, "Max."=NA))
  }
  ## sort our input
  order <- order(vals)
  vals <- vals[order]
  nobs <- nobs[order]

  ## get inverse ecdf for the order statistics
  iFn <- iecdf.binned(vals, nobs)
  result <- c("Min."=iFn(0), "1st Qu."=iFn(0.25), "Median"=iFn(0.5), "Mean"=0, "3rd Qu."=iFn(0.75), "Max."=iFn(1))

  ## but, mean needs to be done differently (not an order statistic).
  ## (max, min, are only "order statistics", as we sorted the matrix
  ## above)
  vsum <- sum(vals*nobs)                # sum of the lot
  population <- sum(nobs)               # number in population
  result["Mean"] <- vsum/population     # average value


  return(result)
}

getout <- function(message, code) {
  if (interactive()) {
    stop(message)
  } else {
    cat(message)
    quit(save="no", status=code)
  }
}


bincps <- function(ifile,      # input file
                   ofile="",   # output csv file ("" ==>
                                        # compute from ifile)
                   ofsep="-",  # separator (when ofile or rfile blank)
                   rfile="",   # output report file (see ofile)
                   fyear=-Inf, # first year to include
                   lyear=Inf,  # last year to include
                   min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                   max99=Inf,  # maximum HH{INCOME,BRACKET}99 (in USD)
                   ## things < min99, > max99 are included in the
                   ## smallest and largest bins; NA are not included
                   binsize=1000,        # size of bins
                   infminmax=FALSE,     # label too small -Inf, too large Inf?
                   verbose=1            # how verbose to be
                   ) {
  if (verbose > 0) {
    cat(sprintf("about to read.csv %s\n", date()))
  }
  dset <<- read.csv(ifile, header=TRUE)
  if (verbose > 0) {
    cat(sprintf("done with read.csv %s\n", date()))
  }
  if (nrow(dset) == 0) {
    getout(sprintf("no data in dataset \"%s\"\n", ifile), 1)
  }

  ## get rid of records outside our years of interest (fyear, lyear)
  if ((fyear != -Inf) || (lyear != Inf)) {
    dset <- dset[dset$YEAR >= fyear & dset$YEAR <= lyear,]
  }

  if (nrow(dset) == 0) {
    getout(sprintf("no data in dataset \"%s\" for years between %g and %g\n",
                   ifile, fyear, lyear), 1)
  }

  ## now, make min99, max99 multiples of binsize
  if (!is.infinite(min99)) {
    min99 <- (min99%/%binsize)*binsize
  }
  if (!is.infinite(max99)) {
    max99 <- (((max99-1)%/%binsize)*binsize)+binsize
  }

  ## now, check if output files are okay
  orlabel <- sprintf("%d%s%d", min(dset$YEAR), ofsep, max(dset$YEAR))
  ofto <- ofsep
  if (min99 != -Inf) {
    orlabel <- sprintf("%s%s%d", orlabel, ofsep, min99);
    ofto <- sprintf("%sto%s", ofsep, ofsep)
  }
  if (max99 != Inf) {
    orlabel <- sprintf("%s%sto%s%d", orlabel, ofsep, ofsep, max99);
    ofto <- ofsep
  }
  orlabel <- sprintf("%s%sbinned", orlabel, ofto)
  rrlabel <- sprintf("%s%sreport", orlabel, ofsep)
  ofile <- dealwithoutputfilename(ifile, ofile, "output", orlabel)
  rfile <- dealwithoutputfilename(ifile, rfile, "report", rrlabel)

  ## we may be running on "raw" (via ipums) census data, or we may be
  ## looking at output of a previous run (already binned).  which is it?
  if (is.element("HHINCOME", colnames(dset))) {
    income99 <- "HHINCOME99"
    ## now, convert all income to 1999 dollars
    dset <- cbind(dset, HHINCOME99=dset$HHINCOME*dset$CPI99)
  } else if (is.element("HHBRACKET99", colnames(dset))) {
    income99 <- "HHBRACKET99"
    ## what is input binsize?  to figure this out, we look at the
    ## smallest difference between successive HHBRACKET99's
    x <- dset$HHBRACKET99                   # brackets
    y <- unique(c(x[2:length(x)], NA) - x) # list of unique deltas + NA
    ibsize <- min(abs(y), na.rm=TRUE)   # take min, ignoring NA
    print(ibsize)
    if (is.na(ibsize)) {
      getout(sprintf("unable to compute input binsize of input file \"%s\"\n",
                     ifile), 1)
    }
    ## now, is the input binsize a divisor of the desired output binsize?
    if ((ibsize%%binsize) != 0) {
      getout(sprintf("the input file appears to have a binsize of %d, but the desired binsize %d is not a multiple of this\n",
                     ibsize, binsize), 1)
    }
  } else {
    getout("bincps: input has neither HHINCOME (raw) or HHBRACKET99 (output of previous run\n", 1)
  }

  rval <- bincps1(dset=dset,
                  min99=min99,
                  max99=max99,
                  binsize=binsize,
                  infminmax=infminmax,
                  verbose=verbose,
                  income99=income99)

  bset <- rval$bset
  rset <- rbind(rval$rsetun, rval$rsethwt, rval$rsetwt)
  write.csv(rval$bset, ofile, row.names=FALSE, quote=FALSE);
  if (nrow(rset) != 0) {                # anything to report?
    ## if so, first sort it, then write it out
    rset <- rset[order(rset$YEAR, rset$"Max."),]
    write.csv(rset, rfile, row.names=FALSE, quote=FALSE)
  }
}

bincps1 <- function(dset,                # inherits other locals from
                    min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                    max99=Inf, # maximum HH{INCOME,BRACKET}99 (in USD)
                    ## things < min99, > max99 are included in the
                    ## smallest and largest bins; NA are not included
                    binsize=1000,        # size of bins
                    infminmax=FALSE,     # should min/max bins be
                                         # labelled "[-]Inf"?  if this
                                         # is FALSE, < min99 will go
                                         # just below the lowest bin,
                                         # and >= max99 will go just
                                         # above the highest bin
                    verbose=1,
                    income99
                    ) {
  ## get *all* the bins...
  dset <- cbind(dset, BRACKET=(floor(dset[,income99]/binsize)*binsize)+binsize)

  ## this is in lieu of a macro facility in R (or in lieu of 
  ## working in org-mode when running code via C-c C-c).  this routine
  ## is called to enter rows into the output table (and, can access --
  ## read and write -- our variables from the calling routine)
  ahroutine <- function(filter, bracket) {
    if (verbose > 1) {
      cat(sprintf("ahroutine, year %d, nrow filter %d, bracket %g, nrow bset %d\n",
                    year, nrow(yset[filter,]), bracket, nrow(bset)))
    }
    for (asecflag in unique(yset[filter,]$ASECFLAG)) {
      if (!is.na(asecflag)) {
        sa <- filter & yset$ASECFLAG == asecflag
      } else {
            sa <- filter & is.na(yset$ASECFLAG)
      }
      for (hflag in unique(yset[sa,]$HFLAG)) {
        if (!is.na(hflag)) {
          sh <- sa & yset$HFLAG == hflag
        } else {
          sh <- sa & is.na(yset$HFLAG)
        }
        if (nrow(yset[sh,]) != 0) {
          ## *finally* -- do something!
          month <- unique(yset[sh,]$MONTH)
          if (length(month) > 1) {
            month <- NA
          }
          cpi99 <- unique(yset[sh,]$CPI99)
          if (length(cpi99) > 1) {
            cpi99 <- NA
          }
          bset <<- rbind(bset,
                         data.frame(YEAR=year,
                                    HWTSUPP=sum(yset[sh,]$HWTSUPP),
                                    ASECFLAG=asecflag,
                                    HFLAG=hflag,
                                    HHBRACKET99=bracket,
                                    CPI99=cpi99,
                                    MONTH=month,
                                    WTSUPP=sum(yset[sh,]$WTSUPP)))
        }
      }
    }
  }

  mysummary <- function(vals, nobs=NULL) {
    "like summary, but try for a format consistent across numbers, NA, ..."
    if (is.null(nobs)) {
      nobs <- rep(1, length(vals))
    }
    summary <- summary.binned(vals, nobs);
    if("NA's" %in% names(summary)) {
      summary <- summary[-which(names(summary) == "NA's")]
    }
    return(summary)
  }

  ## deal with execptional data, i.e., data that is either
  ## NA-contaminated, or data that is outside the min99/max99 bounds
  rsetting <- function(filter, comment) {
    commentun <- sprintf("(unweighted) %s", comment)
    commenthwt <- sprintf("(hwtsupp-weighted) %s", comment)
    commentwt <- sprintf("(wtsupp-weighted) %s", comment)
    rsetun <<- rbind(rsetun,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99]),
                                    COMMENT=commentun))))
    rsethwt <<- rbind(rsethwt,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99],
                                              yset[filter,]$HWTSUPP),
                                    COMMENT=commenthwt))))
    rsetwt <<- rbind(rsetwt,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99],
                                              yset[filter,]$WTSUPP),
                                    COMMENT=commentwt))))
  }

  ## the binned data goes here
  bset <- data.frame()
  ## three data frames for exception reporting.  the first is
  ## unweighted "income99" (HHINCOME99 or HHBRACKET99, as the case may
  ## be); the second weighted by HWTSUPP; and the third by WTSUPP.
  rsetun <- data.frame()
  rsethwt <- data.frame()
  rsetwt <- data.frame()
  for (year in sort(unique(dset$YEAR))) {
    yset <- dset[dset$YEAR == year,]
    sy <- TRUE                          # initially, take all in this year
    if (verbose > 0) {
      cat(sprintf("%s %s\n", year, date()))
    }

    snabit <- is.na(yset[,income99])
    sna <- sy & snabit
    if (nrow(yset[sna,]) != 0) {
      ahroutine(sna, NA)                # enter (these) row(s)
      rsetting(sna, "income not provided")
      sy <- sy & !snabit                # now, kill them
    }

    ## describe and enter the negative incomes
    slowbit <- yset[,income99] < min99
    slow <- sy & slowbit
    if (nrow(yset[slow,]) != 0) {
      ## enter (these) row(s)
      if (!infminmax) {
        ahroutine(slow, min99)
      } else {
        ahroutine(slow, -Inf)
      }
      rsetting(slow, sprintf("less than %d", min99))
      sy <- sy & !slowbit               # now, kill them
    }

    ## now, describe too high incomes (and then enter them below)
    shighbit <- yset[,income99] >= max99
    shigh <- sy & shighbit
    if (nrow(yset[shigh,]) != 0) {
      rsetting(shigh, sprintf("greater than or equal to %d", max99))
      sy <- sy & !shighbit              # now, kill them
    }

    ## we don't describe *other* bins since they are of limited bracket;
    ## the "negative" and "greater than max" bins are not of an a
    ## priori known limit.

    ## now, add all the bins (if there are any!)
    uy <- unique(yset[sy,]$BRACKET)
    if (!is.null(uy)) {
      for (bin in sort(uy)) {
        sb <- sy & yset$BRACKET == bin
        ahroutine(sb, bin)
      }
    }

    ## now, add too high
    if (nrow(yset[shigh,]) != 0) {
      ## enter (these) row(s)
      if (!infminmax) {
        ahroutine(shigh, max99+binsize)
      } else {
        ahroutine(shigh, Inf)
      }
    }
  }
  return(list(bset=bset, rsetun=rsetun, rsethwt=rsethwt, rsetwt=rsetwt))
}

## if necessary, cons up an appropriate FNAME.  then, checks that
## FNAME doesn't already exist and that it is (potentially) writeable.

## NB: as a side effect of testing writeability, on a successful
## return, FNAME *will* exist (but, be empty).
dealwithoutputfilename <- function(ifile, fname, use, lastbits) {
  require(assertthat, quietly=TRUE)

  if (is.na(fname)) {                    # compute filename
    x <- strsplit(ifile, ".", fixed=TRUE)[[1]]
    if (x[length(x)] == "gz") {
      length(x) = length(x)-1           # get rid of .gz (we don't compress)
    }
    x[length(x)] <- sprintf("%s.%s", lastbits, x[length(x)]);
    fname <- paste(x, collapse=".")
  }

  ## test if already exists (a no-no)
  if (file.exists(fname)) {
    getout(sprintf("%s file \"%s\" exists, won't overwrite\n", use, fname), 2)
  }

  ## test if writeable (better be!)
  failed <- FALSE;
  x <- tryCatch(file(fname, "w"), 
                error=function(e) failed <<- TRUE);
  if (failed) {
    getout(sprintf("%s file \"%s\" is not writeable\n", use, fname), 2)
  }
  close(x)

  return(fname)
}

main <- function(args=NULL) {
  require(argparser, quietly=TRUE)

  p <- arg_parser("bincps")
  p <- add_argument(p, "--ifile", type="character", default=NA,
                    help="input data (.csv or .csv.gz) file")
  p <- add_argument(p, "--ofile", type="character", default=NA,

                    help="output data file; if not specified, an automatically generated name will be used")
  p <- add_argument(p, "--rfile", type="character", default=NA,
                    help="output exception report file; if not specified, an automatically generated name will be used")
  p <- add_argument(p, "--ofsep", type="character", default="-",
                    help="separator used when automatically generating ofile, rfile names")
  p <- add_argument(p, "--fyear", type="integer", default=-Inf,
                    help="first year to process; if not specified, the first year in the input file will be used")
  p <- add_argument(p, "--lyear", type="integer", default=Inf,
                    help="last year to process; if not specified, the last year in the input file will be used")
  p <- add_argument(p, "--binsize", type="integer", default=1000,
                    help="output bin size")
  p <- add_argument(p, "--min99", type="integer", default=-Inf, short="-m",
                    help="don't bin dollar amounts below this value")
  p <- add_argument(p, "--max99", type="integer", default=Inf, short="-M",
                    help="don't bin dollar amounts above this value")
  p <- add_argument(p, "--verbose", type="integer", default=0,
                    help="informational/debugging output quantity")
  p <- add_argument(p, "--infminmax", flag=TRUE, default=FALSE,
                    help="should bins for values below min99 (resp. above max99) appear as \"-Inf\" (resp. \"Inf\"); if not, they will be assigned bins just below min99 (resp. just above max99)")

  if (is.null(args)) {
    argv <- parse_args(p)
  } else {
    argv <- parse_args(p, args)
  }

  bincps(ifile=argv$ifile,
         ofile=argv$ofile,
         rfile=argv$rfile,
         ofsep=argv$ofsep,
         fyear=argv$fyear,
         lyear=argv$lyear,
         binsize=argv$binsize,
         min99=argv$min99,
         max99=argv$max99,
         verbose=argv$verbose,
         infminmax=argv$infminmax);
}

runargs <- function(ifile,      # input file
                    ofile=NA,   # output csv file ("" ==>
                                        # compute from ifile)
                    ofsep="-",  # separator (when ofile or rfile blank)
                    rfile=NA,   # output report file (see ofile)
                    fyear=-Inf, # first year to include
                    lyear=Inf,  # last year to include
                    min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                    max99=Inf, # maximum HH{INCOME,BRACKET}99 (in USD)
                    ## things < min99, > max99 are included in the
                    ## smallest and largest bins; NA are not included
                    binsize=1000,        # size of bins
                    infminmax=FALSE,     # label too small -Inf, too large Inf?
                    verbose=1            # how verbose to be
                    ) {
  cmdline <- c("--ifile", ifile,
               "--ofile", "foo.csv",
               "--rfile", "goo.csv",
               "--lyear", lyear,
               "--binsize", binsize,
               "--verbose", verbose)

  main(cmdline)
}

options(error=recover)
options(warn=2)
# debug(bincps1)



if (!interactive()) {
  main()
  print(warnings())
}
