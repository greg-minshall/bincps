#!/usr/bin/env Rscript
getout <- function(message, code) {
  if (interactive()) {
    stop(message)
  } else {
    cat(message)
    quit(save="no", status=code)
  }
}


bincps <- function(ifile,      # input file
                   ofile="",   # output csv file ("" ==>
                                        # compute from ifile)
                   ofsep="-",  # separator (when ofile or rfile blank)
                   rfile="",   # output report file (see ofile)
                   fyear=-Inf, # first year to include
                   lyear=Inf,  # last year to include
                   min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                   max99=Inf,  # maximum HH{INCOME,BRACKET}99 (in USD)
                   ## things < min99, > max99 are included in the
                   ## smallest and largest bins; NA are not included
                   binsize=1000,        # size of bins
                   infminmax=FALSE,     # label too small -Inf, too large Inf?
                   verbose=1            # how verbose to be
                   ) {
  if (verbose > 0) {
    cat(sprintf("about to read.csv %s\n", date()))
  }
  dset <<- read.csv(ifile, header=TRUE)
  if (verbose > 0) {
    cat(sprintf("done with read.csv %s\n", date()))
  }
  if (nrow(dset) == 0) {
    getout(sprintf("no data in dataset \"%s\"\n", ifile), 1)
  }

  ## get rid of records outside our years of interest (fyear, lyear)
  if ((fyear != -Inf) || (lyear != Inf)) {
    dset <- dset[dset$YEAR >= fyear & dset$YEAR <= lyear,]
  }

  if (nrow(dset) == 0) {
    getout(sprintf("no data in dataset \"%s\" for years between %g and %g\n",
                   ifile, fyear, lyear), 1)
  }

  ## now, make min99, max99 multiples of binsize
  if (!is.infinite(min99)) {
    min99 <- (min99%/%binsize)*binsize
  }
  if (!is.infinite(max99)) {
    max99 <- (((max99-1)%/%binsize)*binsize)+binsize
  }

  ## now, check if output files are okay
  orlabel <- sprintf("%d%s%d", min(dset$YEAR), ofsep, max(dset$YEAR))
  ofto <- ofsep
  if (min99 != -Inf) {
    orlabel <- sprintf("%s%s%d", orlabel, ofsep, min99);
    ofto <- sprintf("%sto%s", ofsep, ofsep)
  }
  if (max99 != Inf) {
    orlabel <- sprintf("%s%sto%s%d", orlabel, ofsep, ofsep, max99);
    ofto <- ofsep
  }
  orlabel <- sprintf("%s%sbinned", orlabel, ofto)
  rrlabel <- sprintf("%s%sreport", orlabel, ofsep)
  ofile <- dealwithoutputfilename(ifile, ofile, "output", orlabel)
  rfile <- dealwithoutputfilename(ifile, rfile, "report", rrlabel)

  ## we may be running on "raw" (via ipums) census data, or we may be
  ## looking at output of a previous run (already binned).  which is it?
  if (is.element("HHINCOME", colnames(dset))) {
    income99 <- "HHINCOME99"
    ## now, convert all income to 1999 dollars
    dset <- cbind(dset, HHINCOME1999=dset$HHINCOME*dset$CPI99)
  } else if (is.element("HHBRACKET99", colnames(dset))) {
    income99 <- "HHBRACKET99"
    ## what is input binsize?  to figure this out, we look at the
    ## smallest difference between successive HHBRACKET99's
    x <- dset$HHBRACKET99                   # brackets
    y <- unique(c(x[2:length(x)], NA) - x) # list of unique deltas + NA
    ibsize <- min(abs(y), na.rm=TRUE)   # take min, ignoring NA
    print(ibsize)
    if (is.na(ibsize)) {
      getout(sprintf("unable to compute input binsize of input file \"%s\"\n",
                     ifile), 1)
    }
    ## now, is the input binsize a divisor of the desired output binsize?
    if ((ibsize%%binsize) != 0) {
      getout(sprintf("the input file appears to have a binsize of %d, but the desired binsize %d is not a multiple of this\n",
                     ibsize, binsize), 1)
    }
  } else {
    getout("bincps: input has neither HHINCOME (raw) or HHBRACKET99 (output of previous run\n", 1)
  }

  rval <- bincps1(dset=dset,
                  min99=min99,
                  max99=max99,
                  binsize=binsize,
                  infminmax=infminmax,
                  verbose=verbose,
                  income99=income99)

  bset <- rval$bset
  rset <- rbind(rval$rsetun, rval$rsethwt, rval$rsetwt)
  write.csv(rval$bset, ofile, row.names=FALSE, quote=FALSE);
  if (nrow(rset) != 0) {                # anything to report?
    ## if so, first sort it, then write it out
    rset <- rset[order(rset$YEAR, rset$"Max."),]
    write.csv(rset, rfile, row.names=FALSE, quote=FALSE)
  }
}

bincps1 <- function(dset,                # inherits other locals from
                    min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                    max99=Inf, # maximum HH{INCOME,BRACKET}99 (in USD)
                    ## things < min99, > max99 are included in the
                    ## smallest and largest bins; NA are not included
                    binsize=1000,        # size of bins
                    infminmax=FALSE,     # should min/max bins be
                                         # labelled "[-]Inf"?  if this
                                         # is FALSE, < min99 will go
                                         # just below the lowest bin,
                                         # and >= max99 will go just
                                         # above the highest bin
                    verbose=1,
                    income99
                    ) {
  ## get *all* the bins...
  dset <- cbind(dset, BRACKET=(floor(dset[,income99]/binsize)*binsize)+binsize)

  ## this is in lieu of a macro facility in R (or in lieu of 
  ## working in org-mode when running code via C-c C-c).  this routine
  ## is called to enter rows into the output table (and, can access --
  ## read and write -- our variables from the calling routine)
  ahroutine <- function(filter, bracket) {
    if (verbose > 1) {
      cat(sprintf("ahroutine, year %d, nrow filter %d, bracket %g, nrow bset %d\n",
                    year, nrow(yset[filter,]), bracket, nrow(bset)))
    }
    for (asecflag in unique(yset[filter,]$ASECFLAG)) {
      if (!is.na(asecflag)) {
        sa <- filter & yset$ASECFLAG == asecflag
      } else {
            sa <- filter & is.na(yset$ASECFLAG)
      }
      for (hflag in unique(yset[sa,]$HFLAG)) {
        if (!is.na(hflag)) {
          sh <- sa & yset$HFLAG == hflag
        } else {
          sh <- sa & is.na(yset$HFLAG)
        }
        if (nrow(yset[sh,]) != 0) {
          ## *finally* -- do something!
          month <- unique(yset[sh,]$MONTH)
          if (length(month) > 1) {
            month <- NA
          }
          cpi99 <- unique(yset[sh,]$CPI99)
          if (length(cpi99) > 1) {
            cpi99 <- NA
          }
          bset <<- rbind(bset,
                         data.frame(YEAR=year,
                                    HWTSUPP=sum(yset[sh,]$HWTSUPP),
                                    ASECFLAG=asecflag,
                                    HFLAG=hflag,
                                    HHBRACKET99=bracket,
                                    CPI99=cpi99,
                                    MONTH=month,
                                    WTSUPP=sum(yset[sh,]$WTSUPP)))
        }
      }
    }
  }

  mysummary <- function(vals, nobs=NULL) {
    "like summary, but try for a format consistent across numbers, NA, ..."
    if (is.null(nobs)) {
      nobs <- rep(1, length(vals))
    }
    summary <- summary.binned(vals, nobs);
    if("NA's" %in% names(summary)) {
      summary <- summary[-which(names(summary) == "NA's")]
    }
    return(summary)
  }

  ## deal with execptional data, i.e., data that is either
  ## NA-contaminated, or data that is outside the min99/max99 bounds
  rsetting <- function(filter, comment) {
    commentun <- sprintf("(unweighted) %s", comment)
    commenthwt <- sprintf("(hwtsupp-weighted) %s", comment)
    commentwt <- sprintf("(wtsupp-weighted) %s", comment)
    rsetun <<- rbind(rsetun,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99]),
                                    COMMENT=commentun))))
    rsethwt <<- rbind(rsethwt,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99],
                                              yset[filter,]$HWTSUPP),
                                    COMMENT=commenthwt))))
    rsetwt <<- rbind(rsetwt,
                     data.frame(t(c(YEAR=year,
                                    HWTSUPP=sum(yset[filter,]$HWTSUPP),
                                    WTSUPP=sum(yset[filter,]$WTSUPP),
                                    mysummary(yset[filter,income99],
                                              yset[filter,]$WTSUPP),
                                    COMMENT=commentwt))))
  }

  ## the binned data goes here
  bset <- data.frame()
  ## three data frames for exception reporting.  the first is
  ## unweighted "income99" (HHINCOME99 or HHBRACKET99, as the case may
  ## be); the second weighted by HWTSUPP; and the third by WTSUPP.
  rsetun <- data.frame()
  rsethwt <- data.frame()
  rsetwt <- data.frame()
  for (year in sort(unique(dset$YEAR))) {
    yset <- dset[dset$YEAR == year,]
    sy <- TRUE                          # initially, take all in this year
    if (verbose > 0) {
      cat(sprintf("%s %s\n", year, date()))
    }

    snabit <- is.na(yset[,income99])
    sna <- sy & snabit
    if (nrow(yset[sna,]) != 0) {
      ahroutine(sna, NA)                # enter (these) row(s)
      rsetting(sna, "income not provided")
      sy <- sy & !snabit                # now, kill them
    }

    ## describe and enter the negative incomes
    slowbit <- yset[,income99] < min99
    slow <- sy & slowbit
    if (nrow(yset[slow,]) != 0) {
      ## enter (these) row(s)
      if (!infminmax) {
        ahroutine(slow, min99)
      } else {
        ahroutine(slow, -Inf)
      }
      rsetting(slow, sprintf("less than %d", min99))
      sy <- sy & !slowbit               # now, kill them
    }

    ## now, describe too high incomes (and then enter them below)
    shighbit <- yset[,income99] >= max99
    shigh <- sy & shighbit
    if (nrow(yset[shigh,]) != 0) {
      rsetting(shigh, sprintf("greater than or equal to %d", max99))
      sy <- sy & !shighbit              # now, kill them
    }

    ## we don't describe *other* bins since they are of limited bracket;
    ## the "negative" and "greater than max" bins are not of an a
    ## priori known limit.

    ## now, add all the bins (if there are any!)
    uy <- unique(yset[sy,]$BRACKET)
    if (!is.null(uy)) {
      for (bin in sort(uy)) {
        sb <- sy & yset$BRACKET == bin
        ahroutine(sb, bin)
      }
    }

    ## now, add too high
    if (nrow(yset[shigh,]) != 0) {
      ## enter (these) row(s)
      if (!infminmax) {
        ahroutine(shigh, max99+binsize)
      } else {
        ahroutine(shigh, Inf)
      }
    }
  }
  return(list(bset=bset, rsetun=rsetun, rsethwt=rsethwt, rsetwt=rsetwt))
}

## if necessary, cons up an appropriate FNAME.  then, checks that
## FNAME doesn't already exist and that it is (potentially) writeable.

## NB: as a side effect of testing writeability, on a successful
## return, FNAME *will* exist (but, be empty).
dealwithoutputfilename <- function(ifile, fname, use, lastbits) {
  require(assertthat, quietly=TRUE)

  if (is.na(fname)) {                    # compute filename
    x <- strsplit(ifile, ".", fixed=TRUE)[[1]]
    if (x[length(x)] == "gz") {
      length(x) = length(x)-1           # get rid of .gz (we don't compress)
    }
    x[length(x)] <- sprintf("%s.%s", lastbits, x[length(x)]);
    fname <- paste(x, collapse=".")
  }

  ## test if already exists (a no-no)
  if (file.exists(fname)) {
    getout(sprintf("%s file \"%s\" exists, won't overwrite\n", use, fname), 2)
  }

  ## test if writeable (better be!)
  failed <- FALSE;
  x <- tryCatch(file(fname, "w"), 
                error=function(e) failed <<- TRUE);
  if (failed) {
    getout(sprintf("%s file \"%s\" is not writeable\n", use, fname), 2)
  }
  close(x)

  return(fname)
}

main <- function(args=NULL) {
  require(argparser, quietly=TRUE)

  p <- arg_parser("bincps")
  p <- add_argument(p, "--ifile", type="character", default=NA,
                    help="input data (.csv or .csv.gz) file")
  p <- add_argument(p, "--ofile", type="character", default=NA,

                    help="output data file; if not specified, an automatically generated name will be used")
  p <- add_argument(p, "--rfile", type="character", default=NA,
                    help="output exception report file; if not specified, an automatically generated name will be used")
  p <- add_argument(p, "--ofsep", type="character", default="-",
                    help="separator used when automatically generating ofile, rfile names")
  p <- add_argument(p, "--fyear", type="integer", default=-Inf,
                    help="first year to process; if not specified, the first year in the input file will be used")
  p <- add_argument(p, "--lyear", type="integer", default=Inf,
                    help="last year to process; if not specified, the last year in the input file will be used")
  p <- add_argument(p, "--binsize", type="integer", default=1000,
                    help="output bin size")
  p <- add_argument(p, "--min99", type="integer", default=-Inf,
                    help="don't bin dollar amounts below this value")
  p <- add_argument(p, "--max99", type="integer", default=Inf,
                    help="don't bin dollar amounts above this value")
  p <- add_argument(p, "--verbose", type="integer", default=0,
                    help="how much informational/debugging output should be produced")
  p <- add_argument(p, "--infminmax", flag=TRUE, default=FALSE,
                    help="should bins for values below min99 (resp. above max99) appear as \"-Inf\" (resp. \"Inf\"); if not, they will be assigned bins just below min99 (resp. just above max99)")

  if (is.null(args)) {
    argv <- parse_args(p)
  } else {
    argv <- parse_args(p, args)
  }

  bincps(ifile=argv$ifile,
         ofile=argv$ofile,
         rfile=argv$rfile,
         ofsep=argv$ofsep,
         fyear=argv$fyear,
         lyear=argv$lyear,
         binsize=argv$binsize,
         min99=argv$min99,
         max99=argv$max99,
         verbose=argv$verbose,
         infminmax=argv$infminmax);
}

runargs <- function(ifile,      # input file
                    ofile=NA,   # output csv file ("" ==>
                                        # compute from ifile)
                    ofsep="-",  # separator (when ofile or rfile blank)
                    rfile=NA,   # output report file (see ofile)
                    fyear=-Inf, # first year to include
                    lyear=Inf,  # last year to include
                    min99=-Inf, # minimum HH{INCOME,BRACKET}99 (in USD)
                    max99=Inf, # maximum HH{INCOME,BRACKET}99 (in USD)
                    ## things < min99, > max99 are included in the
                    ## smallest and largest bins; NA are not included
                    binsize=1000,        # size of bins
                    infminmax=FALSE,     # label too small -Inf, too large Inf?
                    verbose=1            # how verbose to be
                    ) {
  cmdline <- c("--ifile", ifile,
               "--ofile", "foo.csv",
               "--rfile", "goo.csv",
               "--lyear", lyear,
               "--min99", 0,
               "--max99", 500000,
               "--binsize", binsize,
               "--verbose", verbose)

  main(cmdline)
}



options(error=recover)
options(warn=2)
# debug(bincps1)



if (!interactive()) {
  main()
  print(warnings())
}
